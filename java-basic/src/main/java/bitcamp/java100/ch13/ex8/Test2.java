// 예외처리 문법정리 : 예외 체인
package bitcamp.java100.ch13.ex8;

public class Test2 {

    // m1() 메서드도 m2()와 같다. 
    static void m1() throws Exception {
        m2();
    }
    
    // m2() 메서드는 m3()와 같다. 
    // m3()가 던지는 예외의 타입을 메서드 선언부에 나열하라!
    static void m2() throws Exception {
        m3();
    }
    
    // m4()가 예외를 던지기 때문에 m3() 에서는 
    // try~ catch~로 m4()가 던진 예외를 처리하거나 
    // 또는 처리하기 싫으면 상위 호출자에게 떠넘겨야 한다.
    // 즉 메서드 선언부에 m4()가 던지는 예외를 나열해야 한다.
    static void m3() throws Exception {
        m4(); // m4()를 호출하면서 
              // 간접적으로 Exception 예외를 발생시키는 것이 된다.
              // 메서드 안에서 예외가 직접적으로 발생하든 
              // 간접적으로 발생하든 간에
              // 메서드 선언부에는 예외 타입을 나열해야 한다.
    }
    
    // m4()에서 예외를 던진다면 메서드 선언부에 
    // 던지는 예외이 타입을 나열해야 한다.
    static void m4() throws Exception {
        throw new Exception();
    }
    
    public static void main(String[] args) {
        // m1()에서 발생한 예외를 main() 메서드에서 처리하지 않는다면,
        // 결국 그 예외는 JVM으로 갈 것이고,
        // JVM은 아무런 준비도 없이 바로 프로그램을 종료할 것이다.
        // 이것이 싫다면 최소한 main()에서는 예외를 처리하라!
        try {
            m1();
        } catch (Exception e) {
            // 예외가 발생했을 때 제대로 종료할 수 있도록 
            // 최소한 main() 메서드에서는 예외를 처리하라!
        }
        
        // Exception 예외의 치명적인 불편함!
        // => Exception 예외를 던지는 메서드를 호출할 때는
        //    반드시 예외처리를 해야 하기 때문에
        //    try~ catch~를 사용하거나,
        //    또는 메서드 선언부에 예외 타입을 나열해야 한다.
        // => 메서드 선언부에 예외 타입을 나열하는 것도 
        //    매우 피곤한 일이다!
        // => 보통 예외는 중간지점이나 최상위 호출 지점에서 
        //    모아서 처리한다.
        //    그래야 로그 파일 관리도 쉽고 예외를 제어하기 편하다.
        // => 즉 이것은 중간에 끼여 있는 메서드를 정의할 때 
        //    사실상 예외 타입을 나열하는 것 자체가 
        //    쓸데없는 일이 된다.
        // => 이를 해결하는 방법은?
        //    스텔스 예외를 던져라!
        //    RuntimeException 예외를 던져라!
    }

}










