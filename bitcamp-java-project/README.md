# 자바 프로젝트

## ver 56
- 모든 서블릿을 JSP로 전환하라!
- 학습목표
  - JSP의 사용법을 익힌다.

## ver 55
- 모든 페이지에 공통으로 실행될 코드를 별도의 서블릿으로 분리하라!
- including 기법을 사용하여 분리된 기능을 포함시켜라!
- 공통 CSS 코드를 별도의 파일을 분리하여 웹페이지에 삽입하라!
- 학습목표
  - 다른 서블릿의 실행 결과를 포함시키는 including 기법을 연습한다.
  - 인클루딩 기법을 통해 공통 코드를 관리하는 방법의 이점을 이해한다.
  - CSS 코드를 외부 파일로 분리하는 방법과 웹페이지에 넣는 방법을 연습한다.

## ver 54
- 모든 페이지의 상단에 메뉴를 넣어라!
- 모든 페이지의 하단에 웹애플리케이션에 대한 정보를 넣어라!
- 학습목표
  - HTML5 시맨틱 태그 사용을 연습한다.
  - Bootstrap 스타일을 적용하는 방법을 연습한다.

## ver 53
- 오픈 소스 CSS 라이브러리인 "Bootstrap"을 화면을 꾸며라!
- npm(node package manager)이라는 패키지 관리자를 사용하여 CSS 라이브러리를 관리한다. 
- 학습목표
  - CSS를 활용하는 방법과 그 효과를 이해한다.
  - CSS, JavaScript 라이브러리를 효과적으로 관리하는 방법을 익힌다. 

## ver 52
- HTML을 이용하여 결과를 출력하라!
- 학습목표
  - HTML 사용법을 익힌다. 

## ver 51
- Command 패턴을 적용하여 각 요청에 대해 한 클래스가 담당하게 한다.
- 이렇게 함으로써 새로 요청을 추가되더라도 기존 클래스의 코드를 변경할 필요없이
  새 기능을 쉽게 추가할 수 있다.
- 학습목표
  - Command 패턴의 사용법을 이해한다.
  - Servlet 클래스를 만드는 방법을 연습한다.

## ver 50
- 기존 프로젝트를 웹애플리케이션 프로젝트로 전환한다.
  즉 이클립에서 웹 프로젝트로 다룰 수 있도록 설정 파일을 변경한다.
- Spring IoC 컨테이너를 서블릿이 아닌 ServletContextListener에서 준비한다.
- 학습목표
  - gradle을 이용하여 이클립스 웹 프로젝트로 전환하는 방법을 연습한다.
  - 서블릿 기술 중에서 리스너를 사용하는 방법을 익힌다.

## ver 49
- Servlet 기술을 도입하여 서블릿 컨테이너에서 실행시킨다.
- 학습목표
  - 웹 애플리케이션을 만들고 배포하고 실행하는 기본 과정을 이해한다.

## ver 48
- Spring IoC 컨테이너를 사용하여 객체 관리(Bean Container) 및 
  의존 객체 주입(DI)을 자동화하라!
- 학습목표
  - Spring IoC 컨테이너의 설정 및 사용방법을 익힌다.
  - Spring IoC 컨테이너의 역할을 이해한다.

## ver 47
- 오픈소스 Reflections 라이브러리를 사용하여 애노케이션이 붙은 클래스를 
  좀 더 쉽게 찾아라!
- 학습목표
  - 오픈 소스 Reflections 라이브러리를 사용하는 방법을 익힌다.
  - 오픈 소스의 유용성에 대해 이해한다.
  - 많이 사람이 참여하여 유지보수를 하고 있다. 
    => 관리가 잘되고, 버그가 적다. 
    => 문서화가 잘되어 있고, 스택오버플로우 사이트에 많은 유용한 답변이 있다.

## ver 46
- 자동으로 인스턴스를 생성할 클래스에 대해 애노테이션으로 표시하라!
- 프로그램을 실행할 때 애노테이션으로 표시된 클래스만 인스턴스를 생성하라!
- 학습목표
  - 애노테이션을 활용하는 방법을 연습한다.
   

## ver 45
- 컨트롤러와 DAO 객체를 자동 생성하라!
- 자동 생성할 클래스 정보를 properties 파일에 등록한 다음,
  프로그램을 시작할 때 해당 파일에 등록된 클래스의 객체를 자동생성한다. 
- 학습목표
  - 객체를 자동 생성하는 방법을 연습한다.
  - Reflection API의 활용법을 이해한다.

## ver 44
- DAO를 교체하기 쉽도록 하라!
- 학습목표
  - 인터페이스 문법을 사용하여  규칙과 구현을 분리시키는 방법을 연습한다.

## ver 43
- 객체의 의존성 관리를 외부에서 처리하게 하라!
- 즉 의존 객체를 직접 만드는 것이 아니라 외부에서 주입하는 방식으로 변경하라!
- 학습목표
  - IoC의 개념과 기능에 대해 이해한다.
  - IoC와 DI의 관계를 이해한다.
  - DI를 구현할 수 있다.

## ver 42
- App 클래스에서 빈 관리 기능을 분리하여 향후 다른 프로젝트에서도 
  사용할 수 있게 하라!
- 학습목표
  - 코드의 재사용성을 높이기 위해 클래스로 분리하는 방법을 연습한다.
  - 빈관리 기능을 수행하는 빈 컨테이너에 대해 이해한다.

## ver 41
- DataSource의 멤버를 스태틱에서 인스턴스로 전환하여 여러 DBMS의 커넥션을 
  다룰 수 있도록 하라!
- 학습목표
  - 스태틱 멤버의 한계와 인스턴스 멤버의 사용이유를 이해한다.
  - 인스턴스를 어디서 생성하고 관리해야 하는지 이해한다.

## ver 40
- DAO의 메서드가 호출될 때마다 Connection 객체를 생성하는 문제점 해결
- 학습목표
  - SQL 문을 매번 실행할 때 마다 DBMS에 연결하는 것 보다 
    한 번 연결한 후에 그 연결 객체를 가지고 SQL 문을 실행하는 것이 
    더 실행속도를 빠르게 한다는 것을 확인한다.
  - DBMS에 연결된 Connection을 사용하는 방법을 연습한다.

## ver39
- DAO(Data Access Object; data persistence 담당) 클래스 도입
- Controller에 있는 JDBC 관련 코드를 별도의 클래스(DAO)로 분리시켜
  "코드를 관리하기 쉽게", "코드를 더 재사용 할 수 있도록" 만든다.
- 학습목표
  - 리팩토링을 수행하는 방법을 이해하고 연습한다.
  - DAO 객체의 역할을 이해하고 만들 수 있다.

## ver38
- DBMS를 사용하여 데이터를 저장하라!
- 학습목표
  - JDBC API를 사용하는 방법을 훈련한다.
  - SQL 사용 방법을 훈련한다. 

## ver 37
- HTTP 프로토콜을 이용하여 통신하게 하라!
- 전용 클라이언트 프로그램 대신 웹브라우저를 클라이언트로 사용하라!
- 학습목표
  - 프로토콜에 대한 개념을 이해한다.
  - HTTP 프로토콜을 이해한다.
  - HTTP 프로토콜에 따라 통신 프로그램을 작성할 수 있다. 

## ver 36
- 버전 35는 한 번 클라이언트와 연결되면 클라이언트와 연결이 끊어질 때까지 계속 요청과 응답을 수행한다. 문제는 클라이언트 사용자가 아무런 일을 시키지 않아도 계속 연결된 채로 있다는 것이다. 즉 메모리 낭비가 이루어진다.
- 버전 35의 문제점을 해결하기 위해 요청할 때마다 연결을 한 후 응답을 하면 연결을 끊는 방식으로 전환한다. 단점 요청할 때마다 연결해야 하기 때문에 요청/응답 시간이 늘어난다. 장점, 클라이언트와 일시적으로 연결되기 때문에 더 많은 클라이언트의 요청을 처리할 수 있다.
- 학습목표
  - Stateful 과 Stateless 방식의 차이점을 이해하고 구현할 수 있다.

## ver 35
- 버전 34는 여러 사람이 서버에 접속 할 수 있지만, 단 접속한 순서대로 크라이언트 요청을 처리하는 방식이다. 접속한 사용자가 종료를 해야만 다음 사용자가 명령을 요청할 수 있는 구조였다.
- 버전 34의 문제점을 해결하기 위해 스레드를 이용하여 여러 사람이 동시에 작업할 수 있도록 한다.
- 학습목표
  - 스레드 사용법을 익힌다.
  
## ver 34
- 여러 사람이 동시에 업무를 볼 수 있도록 C/S(Client/Server) 구조로 
  프로그램을 변경하라!
- 학습목표
  - 네트워킹 프로그래밍을 연습한다.

## ver 33
- 파일의 입출력 속도를 높이기 위해 버퍼 기능을 추가하라!
- 학습목표
  - File API에서 데이터 프로세싱 스트림 클래스의 활용법을 연습한다.
  - BufferedReader와 BufferedWriter의 사용법을 연습한다.

## ver 32
- 사용자가 입력한 데이터를 파일에 저장하여 다음에 프로그램을 실행할 때도
  유지되게 하라!
- 학습목표
  - File API를 활용하는 방법을 연습한다

## ver 31
- 인터페이스를 적용하여 상속의 한계를 극복해보자!
- 학습목표
  - 인터페이스의 사용법과 이점을 익힌다.

## ver 30
- 추상 클래스의 한계
- 학습목표
  - 추상 클래스의 한계를 이해하자!

## ver 29
- 추상 메서드를 이용하여 GenericController의 모든 하위 클래스가 
  반드시 execute()를 오버라이딩하도록 강제하라!
- 학습목표
  - 추상 메서드의 의미와 활용법을 익힌다.
  
## ver 28
- 추상 클래스 문법을 이용하여 GenericController의 인스턴스를 만들지 
  못하게 막아라!
- 학습목표
  - 추상 클래스의 활용법을 익힌다.

## ver 27
- 컨트롤러 클래스들의 공통 점을 찾아 일반화시켜라!
- 즉 상속의 generalization을 수행하라!
- 학습목표
  - 상속의 generalization을 이용해 수퍼 클래스를 정의하는 방법을 익힌다.
  - 수퍼 클래스를 정의했을 때의 이점을 이해한다.

## ver 26
- 코드 리팩토링3
- 학습목표
  - 역할에 따라 클래스를 패키지에 분류한다.

## ver 25
- 코드 리팩토링2
- 학습목표
  - 관련 메서드를 적절하게 클래스로 분류하는 방법을 익힌다.
  
## ver 24
- 코드 리랙토링1
- 학습목표
  - 중복 코드를 별도의 메서드로 분리하는 방법을 익힌다.


## ver 23
- 게시판 기능을 추가하라!
- 자세한 요구사항은 App.java의 주석을 확인하라!
- 학습목표
  - 클래스를 만들고 메서드를 정의하는 것을 연습한다.
  - 복/붙 연습!
  
  
## ver 22
- 회원관리 기능을 추가하라!
- 자세한 요구사항은 App.java의 주석을 확인하라!
- 학습목표
  - 클래스를 만들고 메서드를 정의하는 것을 연습한다.
  

## ver 21
- 메뉴 기능을 추가하라!
- 요구사항 명세는 App.java 주석을 보라!
- 학습목표
  - 클래스 문법을 사용하여 관련 기능을 묶어서 분류하는 기법을 익한다.
  - 콘솔에서 사용자 입력을 다루는 방법을 연습한다.

## ver 20
- 성적관리 입출력을 처리하는 메서드를 별도의 블록으로 분류하라!
- 공통으로 사용하는 메서드도 별도의 클래스로 분리하라!
- 학습목표
  - 클래스 문법을 사용하여 관련 기능을 묶어서 분류하는 기법을 익힌다.


## ver 19
- 사용자 명령을 처리하는 코드를 메서드로 분리하라!
- 학습목표
  - 코드 관리를 쉽게하기 위해 메서드를 이용하는 기법을 익힌다.
  - 리팩토링의 기법 중 "extract method"의 이점에 대해 이해한다.

## ver 18
- 기능 추가: 변경, 삭제 기능을 추가하라!
- 요구사항
  - App.java 클래스의 주석을 확인하라!

## ver 17
- 자바에서 제공하는 컬렉션 API를 사용하라!
- 즉 java.util.ArrayList를 사용하여 성적 데이터 목록을 다뤄라.
- 학습목표
  - 자바의 컬렉션 API 사용법을 익힌다.
  - Iterator를 사용하여 값을 꺼내는 방법.

## ver 16
- ArrayList에 generic을 적용하여 저장하는 타입을 지정할 수 있게 한다.
- 학습목표
  - 제넥릭을 이용하여 클래스를 정의하는 방법
  - 제네릭이 적용된 클래스를 사용하는 방법

## ver 15
- ScoreDao를 다른 타입에 대해서도 처리할 수 있도록 변경하라!
- 학습목표
  - 다형성의 특징 중 다형적 변수를 활용하는 방법을 연습한다.

## ver 14
- 모든 무소속 클래스를 패키지 멤버 클래스로 만들라! 
- Score 클래스에 캡슐화 문법을 적용하라!
- 학습목표
  - 클래스를 패키지 멤버로 만드는 방법을 학습한다.
  - 각 필드나 메서드의 접근을 제한하는 방법을 연습한다.
  - 셋터/겟터의 정의와 사용을 연습한다.

## ver 13
- ScoreDao 클래스의 스태틱 멤버를 인스턴스 멤버로 전환하라!
- 학습 목표
  - 스태틱 변수를 인스턴스 변수로 바꿨을 때 어떤 이점이 있는지 이해한다.
  
## ver 12
- Score 객체의 주소를 저장하고 꺼내는 코드를 별도의 클래스로 분리하라!
- 학습 목표
  - 기능 별로 클래스를 분류하는 과정을 이해하고 연습한다.

## ver 11
- 키보드로 성적 정보를 입력 받아 저장하라!
- 계속 저장할 지 여부를 물어봐라!
- 저장을 완료하면 모든 성적을 출력하라!
- 학습 목표
  - 생성자의 목적
  - 인스턴스 메서드와 스태틱 메서드의 구분
  - 메서드를 적절하게 클래스로 분류하는 예 

## ver 10
- 생성자를 이용하여 인스턴스를 초기화시키라.
- 인스턴스를 다루는 메서드는 인스턴스 메서드로 전환하라. 

## ver 09
- 리팩토링(refactoring)을 수행한다.
- 즉 메서드를 관리하기 쉽도록 별도의 클래스로 분류하라!

## ver 08
- 클래스를 관리하기 쉽도록 별도의 파일로 분리하다. 
- 메서드를 사용하여 반복 코드를 분리한다.

## ver 07
- 배열 응용 II
ver-06에서 Score 객체를 배열에 저장하라!

## ver 06
- 배열 응용
ver-05에서 국,영,수 성적을 배열에 저장하라!

## ver 05
- 클래스 문법 응용
ver-04에서 작업한 코드를 클래스 문법을 적용하여 변경하라!

## ver 04
- 배열 문법 응용

여러 명의 성적을 저장하고 다음과 같이 출력하라!

출력내용:
```
홍길동, 100,  90,  80, 270,  90.0
임꺽정,  80,  80,  80, 240,  80.0
유관순, 100, 100, 100, 300, 100.0
```
## ver 03
- 변수 응용 

변수를 이용하여 이름, 국어, 영어, 수학, 총점, 합계를 저장하라!그런 후 다음과 같이 출력하라!

출력 내용:
```
이름: 홍길동
국어: 100
영어: 100
수학: 100
총점: 300
평균: 100.0
```


## ver 02
- 다양한 데이터 타입의 리터럴 응용

학생 한 명의 성적 점수를 출력하라!

출력 내용은 다음과 같다.
```
이름: 홍길동
국어: 100
영어: 100
수학: 100
총점: 300
평균: 100.0
```
## ver 01
- 출력 기능 응용

표준 출력장치로 인사문구 출력하라!

출력 내용은 다음과 같다.
```
Hello, world!
```