// 캡슐화의 존재 이유
// => 인스턴스 변수에 무효한 값이 저장되는 것을 방지함으로써
//    추상화가 무너지는 것을 막는다.
//
// => 추상화(abstraction)?
//    사물이나 사람, 업무 등을 데이터와 메서드로 표현한 것.
//    즉 클래스를 정의하는 것을 말한다.
//
// => 객체지향의 출발점은 클래스를 식별하여 정의하는 것으로 시작한다.
// 
// => 어떻게? 
//    객체지향 분석/설계(OOA/D, Object-Oriented Analysis and Design)를 통해
//    어떤 클래스가 있어야 하는지, 그 클래스에 어떤 필드와 메서드가 있어야 하는지
//    찾아내어 클래스로 정의한다.
// 
package bitcamp.java100.ch08.ex1;

// Gym 회원을 추상화 해보자!
class Member {
    String name;
    int age;
    float weight;
    float height;
}

public class Test7_1 {
    public static void main(String[] args) {
        Member m = new Member();
        m.name = "홍길동";
        m.age = 20;
        
        // 다음 코드는 몸무게와 키를 저장한다.
        // 문법으로는 아무런 문제가 없다.
        // 하지만 내용에서는 Gym 회원이 아니다. 
        // 이것은 괴물 데이터이다.
        // 이렇게 Member 객체에 Gym 회원에 맞지 않는 무효한 괴물 데이터를
        // 넣게 되면 시스템 실행시 원하지 않는 결과를 뽑게 된다.
        // 예) Gym 회원의 평균 몸무게와 평균 키를 뽑을 때
        // 잘못된 데이터 때문에 전체 회원의 평균 몸무게와 평균 키 값이 왜곡되는 
        // 문제가 발생한다.
        // 이런 경우가 바로 "캡슐화"를 무너뜨리는 예이다.
        // Member 클래스는 Gym 회원 정보를 표현하는 클래스이지 괴물을 표현하기 위해 
        // 만든 클래스가 아니다.
        // 
        // 만약 이 Member를 병원에서 사용한다면 훨씬 치명적이다.
        // 왜? 병원은 나이와 몸무게에 따라 약을 처방하기 때문이다.
        // 몸무게가 많이 나가면 그에따라 약의 투여량이 증가한다.
        // 따라서 몸무게가 왜곡된 상태에서 그 왜곡된 값을 바탕으로 약을 투여한다면
        // 환자의 생명이 위독할 수 있는 경우가 발생할 것이다.
        // 
        // 그럼 이렇게 무효한 값이 들어가는 문제가 발생하는 이유는 뭔가?
        // => 개발자가 직접 변수에 접근해서 임의의 값을 넣을 수 있기 때문이다.
        // 이것을 어떻게 막아야 하는가?
        // => 개발자가 직접 변수에 접근하지 못하게 막아야한다.
        // => 또는 사용 권한이 없는 코드에서 이 변수의 값을 임의적으로 변경하는 것을 
        //    막아야 한다.
        // 방법은?
        // => 변수나 메서드의 접근 범위를 조정하면 된다.
        // => 모든 것을 완벽하게 막지는 목하겠지만, 그래도 잘못된 무효한 값을 
        //    넣을 가능을 최소화시키는 것이 좋다!
        m.weight = 900.7f;
        m.height = 16.0f;
        
    }
}











